const t=()=>Math.random().toString(36).substring(2,16),e=t=>new Promise((e=>{setTimeout((()=>e()),t)})),n=()=>({name:"foo",steps:{one:{},two:{}}}),o=t=>{const e={name:"foo",steps:{one:{},two:{}}};return e.foo=null===t?{bar:"baz"}:[{bar:"baz"},t||"all"],e},r=(t,e,n)=>new Promise(((o,r)=>{const s=()=>{t.off(e,s),o()};try{t.on(e,s),n()}catch(t){r(t)}})),s=async(t,e=(()=>t.start()))=>r(t,"started",e),a=async(t,e=(()=>t.current.complete()))=>r(t,"step",e),c=async(t,e=(()=>t.current.complete()))=>r(t,"end",e),i=async(t,e)=>r(t,"error",e),l=async t=>{const e=t.history[t.history.length-1];await a(t,(()=>t.step(e.name)))},m=t=>e=>{const n=e.id;return e.id=t,()=>{e.id=n}},p=t=>{const e=[];for(;null!=t;t=Object.getPrototypeOf(t)){const n=Object.getOwnPropertyNames(t);for(let t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t])}return e},u=p({});export{r as asyncEvent,e as asyncTimeout,c as end,i as error,n as minimalFlow,o as minimalFlowWithExtension,a as next,u as objectProps,l as prev,p as props,m as setId,t as simpleId,s as start};//# sourceMappingURL=index.min.js.map
