{"version":3,"file":"withInstances.min.mjs","sources":["../withInstances.cjs"],"sourcesContent":["/**\n * @namespace Tinyflow\n */\n\n/**\n * Tinyflow extension to manage instances (create, get, dispose).\n *\n * @function\n * @export\n * @return {function(*, {Workflow: *, Tinyflow: *, TinyflowError: *}): function(): void}\n */\nmodule.exports.withInstances = (/* config */) => (internal, { Workflow, Tinyflow, TinyflowError }) => {\n  internal.instances = new Map()\n  const { instances, listeners } = internal\n\n  /**\n   * Gets a workflow instance by its id\n   * @method\n   * @param id {string}\n   * @returns {Workflow}\n   */\n  Tinyflow.get = id => instances.get(id)\n\n  /**\n   * Returns all non-disposed workflows of any state.\n   * @method\n   * @return {Workflow[]}\n   */\n  Tinyflow.all = () => [...instances.values()]\n\n  /**\n   * Clears all instances. By default, all engines are shut down\n   * and fire the end event.\n   * @method\n   */\n  Tinyflow.clear = () => {\n    const ids = [...instances.keys()]\n    for (const instanceId of ids) {\n      const workflow = Tinyflow.get(instanceId)\n      workflow.cancel()\n      Tinyflow.dispose(instanceId)\n    }\n  }\n\n  /**\n   * Creates a new workflow instance by given workflow definitions.\n   *\n   * @param definition {object} the workflow definitions object\n   * @returns {Workflow}\n   */\n  Tinyflow.create = (definition) => {\n    const workflow = new Workflow(definition)\n    instances.set(workflow.id, workflow)\n    return workflow\n  }\n\n  /**\n   * Fully disposes a workflow, including any event listener\n   * to it, or its current step.\n   * Once complete it will finally remove the workflow from\n   * the internal instances list.\n   * @param instanceId {string}\n   * @param force {boolean=}\n   */\n  Tinyflow.dispose = (instanceId, { force = false } = {}) => {\n    const workflow = instances.get(instanceId)\n    if (!workflow) {\n      throw new TinyflowError(`Workflow does not exist by id ${instanceId}`)\n    }\n    if (!force && workflow.state === 'active') {\n      throw new TinyflowError(`Cannot dispose active workflow \"${workflow.name}\"`, { instanceId })\n    }\n    if (workflow.current) {\n      workflow.current.off()\n      workflow.current = null\n    }\n    workflow.off()\n    listeners.delete(workflow)\n    instances.delete(instanceId)\n  }\n\n  // dispose method for complete cleanup of this extension\n  return () => {\n    delete internal.instances\n    delete Tinyflow.get\n    delete Tinyflow.all\n    delete Tinyflow.clear\n    delete Tinyflow.create\n    delete Tinyflow.dispose\n  }\n}\n"],"names":["withInstances_1","internal","Workflow","Tinyflow","TinyflowError","instances","Map","listeners","get","id","all","values","clear","ids","keys","instanceId","cancel","dispose","create","definition","workflow","set","force","state","name","current","off","delete"],"mappings":"AAWA,IAAAA,EAA+B,IAAkB,CAACC,GAAYC,WAAUC,WAAUC,oBAChFH,EAASI,UAAY,IAAIC,IACzB,MAAMD,UAAEA,EAASE,UAAEA,GAAcN,EAqEjC,OA7DAE,EAASK,IAAMC,GAAMJ,EAAUG,IAAIC,GAOnCN,EAASO,IAAM,IAAM,IAAIL,EAAUM,UAOnCR,EAASS,MAAQ,KACf,MAAMC,EAAM,IAAIR,EAAUS,QAC1B,IAAK,MAAMC,KAAcF,EAAK,CACXV,EAASK,IAAIO,GACrBC,SACTb,EAASc,QAAQF,EAClB,GASHZ,EAASe,OAAUC,IACjB,MAAMC,EAAW,IAAIlB,EAASiB,GAE9B,OADAd,EAAUgB,IAAID,EAASX,GAAIW,GACpBA,GAWTjB,EAASc,QAAU,CAACF,GAAcO,SAAQ,GAAU,MAClD,MAAMF,EAAWf,EAAUG,IAAIO,GAC/B,IAAKK,EACH,MAAM,IAAIhB,EAAc,iCAAiCW,KAE3D,IAAKO,GAA4B,WAAnBF,EAASG,MACrB,MAAM,IAAInB,EAAc,mCAAmCgB,EAASI,QAAS,CAAET,eAE7EK,EAASK,UACXL,EAASK,QAAQC,MACjBN,EAASK,QAAU,MAErBL,EAASM,MACTnB,EAAUoB,OAAOP,GACjBf,EAAUsB,OAAOZ,EAAW,EAIvB,YACEd,EAASI,iBACTF,EAASK,WACTL,EAASO,WACTP,EAASS,aACTT,EAASe,cACTf,EAASc,OAAO,CACxB,SACHjB"}