const t={},e={extensions:new Map,listeners:new WeakMap,id:()=>Math.random().toString(16).substring(2,16),history:t=>({name:t.name,data:{...t.data},at:new Date})},{extensions:s,listeners:i}=e;i.by=(t,e)=>(i.has(t)||i.set(t,new Map),i.get(t).get(e)||[]),t.extend=s=>s(e,{Tinyflow:t,TinyflowError:r,Workflow:h,Step:c,Emitter:a}),t.use=(t,e)=>{(null===e?s.delete:s.set).call(s,t,e)};const n=(t,e=0)=>setTimeout(t,e);class a{on(t,e){const s=i.by(this,t);s.push(e),i.get(this).set(t,s)}once(t,e){e.once=!0,this.on(t,e)}off(t,e){if(!t)return void i.get(this).clear();const s=i.by(this,t);e||(s.length=0);const n=s.length>0&&s.findIndex((t=>t===e));if(!(n>-1))throw new r(`No listener found by function for event ${t}`,{id:this.id,name:this.name});s.splice(n,1),i.get(this).set(t,s)}emit(t,e){const s=i.by(this,t).reverse();for(let t=s.length-1;t>=0;t--){const i=s[t];n((()=>{var t,s;(t=i,s=[e],new Promise(((e,i)=>{try{e(t(...s))}catch(t){i(t)}}))).catch((t=>this.emit("error",{error:t,source:this})))})),i.once&&s.splice(t,1)}i.get(this).set(t,s)}}class r extends Error{constructor(t,e){super(t),this.name="TinyflowError",this.details=e}}const o=({workflow:t,step:e,onSuccess:i,onError:n})=>{const a=t||e;Promise.all(Object.keys(a.custom).filter((t=>s.has(t))).map((i=>s.get(i)(a.custom[i],{workflow:t,step:e})))).then(i).catch(n)};class h extends a{constructor({name:t,id:s,steps:i={},...n}){super(),this.name=t,this.id=s||e.id(),this.data=null,this.state="pending",this.custom={},this.history=[];const a={};if(Object.entries(n).forEach((([t,e])=>{const[s,i]=Array.isArray(e)?e:[e,"all"];["all","workflow"].includes(i)&&(this.custom[t]=s),["all","steps"].includes(i)&&(a[t]=s)})),this.steps=Object.entries(i).map((([t,e],s,i)=>({next:s<i.length-1?s+1:null,name:t,...a,...e}))),0===this.steps.length)throw new r("Workflow steps must have at least one entry, got 0",{name:t,id:s});this.current=null}start({autoStep:t}={}){if("active"===this.state)throw new r("Cannot start active workflow",{name:this.name,id:this.id});this.data=Object.create(null);const e=this;o({workflow:e,onSuccess:()=>{this.state="active",this.emit("started",this),!1!==t&&this.step(0)},onError:t=>this.emit("error",{error:t,workflow:e})})}step(t,{stepId:s,autoOnEnd:i}={}){if("active"!==this.state)throw new r(`Can only step in an active state, got "${this.state}"`,{indexOrName:t,name:this.name,id:this.id});const a="number"==typeof t?this.steps[t]:this.steps.find((({name:e})=>e===t));if(!a)throw new r(`Expected step definition, got ${a}`,{indexOrName:t,name:this.name,id:this.id});const o=s||e.id(),h=this.id,l=new c({id:o,workflowId:h,...a}),d=this,m=t=>(t&&(t.off(),this.history.push(e.history(t,d))),!0);!1!==i&&l.once("end",(t=>{d.data[t.name]={...t.data};const e=t.next;return null!==e&&e<=d.steps.length-1?n((()=>d.step(e))):m(t)&&d.complete()})),l.start(),m(this.current),this.current=l,this.emit("step",this)}complete(){this.current&&this.current.off(),this.current=null,this.state="complete",this.emit("end",this)}cancel(){this.current&&this.current.off(),this.data=null,this.current=null,this.state="cancelled",this.emit("end",this)}}class c extends a{constructor({id:t,workflowId:s,name:i,data:n=null,next:a,...r}){super(),this.id=t||e.id(),this.workflowId=s,this.name=i,this.next=a,this.custom=r,this.state="pending",this.data=n}start(){if("active"===this.state)throw new r("Cannot start a step in active state",{name:this.name,id:this.id,wf:this.workflowId});this.data=this.data||Object.create(null);const t=this;o({step:t,onSuccess:()=>{this.state="active",this.emit("started",this)},onError:e=>this.emit("error",{error:e,step:t})})}update(t){if("active"!==this.state)throw new r(`Can only update in an active state, got "${this.state}"`,{name:this.name,id:this.id,wf:this.workflowId});this.data=Object.create(null),Object.assign(this.data,t),this.emit("update",this)}complete(){this.state="complete",this.emit("end",this)}cancel(){this.state="cancelled",this.data=null,this.emit("end",this)}}export{c as Step,t as Tinyflow,h as Workflow};//# sourceMappingURL=Tinyflow.min.js.map
